/*Типы в TypeScript:

- примитивы: string, number, undefined, null, boolean и enum (менее распространенные bigint и symbol)
- массивы: number[], string[], Array<number>
- специальный тип any, который можно использовать всякий раз, когда нужно, чтобы определенное значение не вызывало ошибки проверки типов.
- noImplicitAny - этот флаг используется, чтобы пометить любую неявную any ошибку как ошибку.
- функции - когда объявляется функция, можно добавить аннотации типа после каждого параметра, чтобы объявить, какие типы параметров принимает функция, а также можно добавить
аннотации типа возвращаемого значения.

function greet(name: string): string {
  return ("Hello, " + name.toUpperCase() + "!!");
}

Анонимные функции отличаются от объявлений функций. Когда функция появляется там, где TypeScript может определить, как она будет вызываться, параметрам этой функции
автоматически присваиваются типы. Этот процесс называется контекстной типизацией, поскольку контекст, в котором возникла функция, сообщает, какой тип она должна иметь.

- объекты - типы объектов также могут указывать, что некоторые или все их свойства являются необязательными. Для этого добавляется "?" после имени свойства*/
//

//Объединение - это тип, образованный из двух или более других типов и представляющий значения, которые могут быть любым из этих типов (id: number | string).

//
/*Для использования одного и того же типа более одного раза и ссылаться на него по одному имени существует конструкции "type" и "interface".

type Point = {
  x: number;
  y: number;
};

interface Point {
  x: number;
  y: number;
}

Различия между type и interface

Types и Interfaces очень похожи и во многих случаях можно свободно выбирать между ними. В большинстве случаев type используются для создания более сложного типа и повторного
использования этого имени. С другой стороны, interface используются для объектно-ориентированных целей, в которых определяется форма объекта, а затем используется в качестве
параметров функции или для реализации класса.
- Одним из наиболее существенных функциональных отличий между type и interface является то, что, с type мы можем объединить нескольких других type, то есть расширить его
посредством пересечений (&) с другими Type.
- Ещё одно функциональное различие между interface и type заключается в том, что если у нас два interface с одинаковыми именами, при использовании они будут объединены вместе и мы
получим доступ к свойствам и первого и второго интерфейса. Interface расширяется посредством Extends или простым добавление нового поля в его структуру.*/

/*Если используется document.getElementById, TypeScript знает только, что он вернет какой-то тип HTMLElement, но вы можете знать, что ваша страница всегда будет иметь
 HTMLCanvasElementзаданный идентификатор. В этой ситуации вы можете использовать утверждение типа "as", чтобы указать более конкретный тип:

const myCanvas = document.getElementById("main_canvas") as HTMLCanvasElement;*/

/*Объединяя литералы в объединения, можно выразить гораздо более полезную концепцию — например, функции, которые принимают только определенный набор известных значений:

function printText(s: string, alignment: "left" | "right" | "center") {
  // ...
}*/

/*TypeScript имеет null и undefined. Поведение этих типов зависит от того, включена ли у вас strictNullChecks опция. Если она выключена, то эти типы могут быть назначены любому
свойству и к ним можно получить доступ. Если включена - необходимо провести проверку прежде чем использовать методы или свойства для этого значения.
TypeScript также имеет специальный синтаксис для удаления null и undefinedудаления типа без какой-либо явной проверки. Запись "!" после любого выражения фактически
является утверждением типа, что значение не равно null или undefined*/

/*TypeScript предлагает полную поддержку ключевого слова class.

- strictPropertyInitialization - этот параметр определяет, нужно ли инициализировать поля класса в конструкторе.
- readonly - поля могут иметь этот префикс. Это предотвращает присвоение поля вне конструктора.

Есть несколько различий между сигнатурами конструкторов классов и сигнатурами функций:

- конструкторы не могут иметь параметры типа — они принадлежат объявлению внешнего класса.
- конструкторы не могут иметь аннотации типа возвращаемого значения — тип экземпляра класса всегда является тем, что возвращается.

Так же в class присутствует метод super() для вызова конструктора родителя.

TypeScript имеет некоторые специальные правила вывода для средств доступа:

- если get существует, но нет set, свойство автоматически readonly.
- если тип параметра сеттера не указан, он берется из типа возвращаемого значения геттера.
- геттеры и сеттеры должны иметь одинаковую видимость членов (Member Visibility: public, protected, private).

Ключевое слово implements используется для того, чтобы проверить, что класс удовлетворяет определенному interface. Будет выдана ошибка, если класс не сможет правильно
реализовать методы interface.

Ключевое слово extends используется для наследования классов.

Порядок инициализации класса, определенный в JavaScript, следующий:

- поля базового класса инициализируются
- конструктор базового класса запускается
- поля производного класса инициализируются
- конструктор производного класса запускается

Классы могут иметь static членов. Эти члены не связаны с конкретным экземпляром класса. Доступ к ним можно получить через сам объект конструктора класса.

Классы, как и интерфейсы, могут быть универсальными (принцип как у джененриков). Когда создается экземпляр универсального класса с помощью new, его параметры типа выводятся
так же, как и при вызове функции*/

/* Utility Types:
- partial(принимает в себя объект и делает все поля опциональными),
- required(принимает объект и делает все поля обязательными),
- omit(принимает в себя объект первым аргументом и название поля внутри этого объекта, которое нужно исключить из него),
- pick(почти как омит, но он выбирает одно свойство из объекта, остальное забывает),
- exclude(исключает из членов объединения (а | b) те члены, которые передаются вторым параметром).
Вспомогательные глобальные типы, генерики */

/*Enum — это конструкция, состоящая из набора именованных констант (список перечисления) и определяемая такими примитивными типами, как number и string. Применяется тогда,
когда нужна двухсторонняя ассоциация строкового ключа с его числовым или строковым значением. Если указать значение частично, то компилятор будет стараться соблюдать
последовательность, которая автоматически рассчитывается только на основе значения предыдущего члена перечисления.

enum Citrus {
  Lemon = 2, // 2
  Orange = 4, // 4
  Lime = 6, // 6
}
*/

//
//

//Дженерики (Generics)

//Дженерики — это возможность создавать компоненты, работающие не только с одним, а с несколькими типами данных.

/*Дженерики или универсальный тип.
// Какие генерики бывают? Интерфейс, тип, функция, класс

function getProperty<T, K extends typeof T>(obj: T, key: K) {
    return obj[key]
}

const myObj = {
    a: 1,
    b: 2,
}

getProperty(если тип Т один, то мы его, как правило, явно указываем. например <number>)(meObj, "a")*/

/*Дженерики и типы соотносятся друг с другом, как значения и аргументы функции. Это такой способ сообщить компонентам
(функциям, классам или интерфейсам), какой тип необходимо использовать при их вызове так же, как во время вызова мы сообщаем функции,
какие значения использовать в качестве аргументов.

function identity<T>(value: T): T {
  return value;
}

console.log(identity < Number > 1);

При вызове identity<Number>(1), тип Number — это аргумент, который подставляется везде вместо T.
Функция может принимать несколько типов аналогично тому, как она принимает несколько аргументов.
*/
