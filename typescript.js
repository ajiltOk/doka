/*Типы в TypeScript:

- примитивы: string, number, и boolean (менее распространенные bigint и symbol)
- массивы: number[], string[], Array<number>
- специальный тип any, который можно использовать всякий раз, когда нужно, чтобы определенное значение не вызывало ошибки проверки типов.
- noImplicitAny - этот флаг используется, чтобы пометить любую неявную any ошибку как ошибку.
- функции - когда объявляется функция, можно добавить аннотации типа после каждого параметра, чтобы объявить, какие типы параметров принимает функция, а также можно добавить
аннотации типа возвращаемого значения.

function greet(name: string): string {
  return ("Hello, " + name.toUpperCase() + "!!");
}

Анонимные функции отличаются от объявлений функций. Когда функция появляется там, где TypeScript может определить, как она будет вызываться, параметрам этой функции
автоматически присваиваются типы. Этот процесс называется контекстной типизацией, поскольку контекст, в котором возникла функция, сообщает, какой тип она должна иметь.

- объекты - типы объектов также могут указывать, что некоторые или все их свойства являются необязательными. Для этого добавляется "?" после имени свойства*/

//
//Объединение - это тип, образованный из двух или более других типов и представляющий значения, которые могут быть любым из этих типов (id: number | string).
//

/*Для использования одного и того же типа более одного раза и ссылаться на него по одному имени существует конструкции "type" и "interface".

type Point = {
  x: number;
  y: number;
};

interface Point {
  x: number;
  y: number;
}

Ключевое отличие между "type" и "interface" состоит в том, что "type" не может быть повторно открыт для добавления новых свойств по сравнению с "interface",
который всегда расширяется.*/

/*Если используется document.getElementById, TypeScript знает только, что он вернет какой-то тип HTMLElement, но вы можете знать, что ваша страница всегда будет иметь
 HTMLCanvasElementзаданный идентификатор. В этой ситуации вы можете использовать утверждение типа "as", чтобы указать более конкретный тип:

const myCanvas = document.getElementById("main_canvas") as HTMLCanvasElement;*/

/*Объединяя литералы в объединения, можно выразить гораздо более полезную концепцию — например, функции, которые принимают только определенный набор известных значений:

function printText(s: string, alignment: "left" | "right" | "center") {
  // ...
}*/

/*TypeScript имеет null и undefined. Поведение этих типов зависит от того, включена ли у вас strictNullChecks опция. Если она выключена, то эти типы могут быть назначены любому
свойству и к ним можно получить доступ. Если включена - необходимо провести проверку прежде чем использовать методы или свойства для этого значения.
TypeScript также имеет специальный синтаксис для удаления null и undefinedудаления типа без какой-либо явной проверки. Запись "!" после любого выражения фактически
является утверждением типа, что значение не равно null или undefined*/

//

/*Дженерики или универсальный тип.
// Какие генерики бывают? Интерфейс, тип, функция, класс

function getProperty<T, K extends typeof T>(obj: T, key: K) {
    return obj[key]
}

const myObj = {
    a: 1,
    b: 2,
}

getProperty(если тип Т один, то мы его, как правило, явно указываем. например <number>)(meObj, "a")*/

/*TypeScript предлагает полную поддержку ключевого слова class.

- strictPropertyInitialization - этот параметр определяет, нужно ли инициализировать поля класса в конструкторе.
- readonly - поля могут иметь этот префикс. Это предотвращает присвоение поля вне конструктора.

Есть несколько различий между сигнатурами конструкторов классов и сигнатурами функций:

- конструкторы не могут иметь параметры типа — они принадлежат объявлению внешнего класса.
- конструкторы не могут иметь аннотации типа возвращаемого значения — тип экземпляра класса всегда является тем, что возвращается.

Так же в class присутствует метод super() для вызова конструктора родителя.

TypeScript имеет некоторые специальные правила вывода для средств доступа:

- если get существует, но нет set, свойство автоматически readonly.
- если тип параметра сеттера не указан, он берется из типа возвращаемого значения геттера.
- геттеры и сеттеры должны иметь одинаковую видимость членов (Member Visibility: public, protected, private).

Ключевое слово implements используется для того, чтобы проверить, что класс удовлетворяет определенному interface. Будет выдана ошибка, если класс не сможет правильно
реализовать методы interface.

Ключевое слово extends используется для наследования классов.

Порядок инициализации класса, определенный в JavaScript, следующий:

- поля базового класса инициализируются
- конструктор базового класса запускается
- поля производного класса инициализируются
- конструктор производного класса запускается

Классы могут иметь static членов. Эти члены не связаны с конкретным экземпляром класса. Доступ к ним можно получить через сам объект конструктора класса.

Классы, как и интерфейсы, могут быть универсальными (принцип как у джененриков). Когда создается экземпляр универсального класса с помощью new, его параметры типа выводятся
так же, как и при вызове функции*/

/* Utility Types:
- partial(принимает в себя объект и делает все поля опциональными),
- required(принимает объект и делает все поля обязательными),
- omit(принимает в себя объект первым аргументом и название поля внутри этого объекта, которое нужно исключить из него),
- pick(почти как омит, но он выбирает одно свойство из объекта, остальное забывает),
- exclude(исключает из членов объединения (а | b) те члены, которые передаются вторым параметром).
Вспомогательные глобальные типы, генерики */

//В TypeScript есть три  примитива : string, numberи boolean.

//Если в качестве входных даный используется массив строк или массив чисел, то используется следующий синтаксис:

    - string[] или number[]
    - Array<string> или Array<number>

//Определение входящих параметров функции:

    function greet(name: string) {
        console.log("Hello, " + name.toUpperCase() + "!!");
    }

//Определение возвращаемых параметров функции:

    function getFavoriteNumber(): number {
        return 26;
    }

//Определение параметров функции, которая возвращает Promise:

    async function getFavoriteNumber(): Promise<number> {
        return 26;
    }

/*Для ананимных (стрелочных) функций применяется контекстная типизация, поскольку контекст, в котором возникла функция, сообщает,
какой тип она должна иметь.*/

/*Если тип входящих параметров может менятся в процессе работы приложения или для его корректной работы подходят несколько типов входящих параметров
применяется объединение типов.*/

    function printId(id: number | string) {
        console.log("Your ID is: " + id);
    }

//Для того, чтобы ссылаться на один и тот же тип более одного раза по одному имени используется Type Alias или Interface.

    type Point = {
        x: number;
        y: number;
    };

    interface Point {
        x: number;
        y: number;
      }
   
    function printCoord(pt: Point) {
        console.log("The coordinate's x value is " + pt.x);
        console.log("The coordinate's y value is " + pt.y);
    }
   
    printCoord({ x: 100, y: 100 });

/*Types и Interfaces очень похожи и во многих случаях можно свободно выбирать между ними.
Почти все функции Interface доступны в Type, ключевое отличие состоит в том, что Type не может быть повторно открыт для добавления новых свойств
по сравнению с Interface, который всегда расширяется. Interface расширяется посредством Extends или простым добавление нового поля в его структуру.
Type же расширяется посредством пересечений (&) с другими Type, но после создания саму структуру Type изменить нельзя.*/

//
//
//

//Дженерики (Generics)

//Дженерики — это возможность создавать компоненты, работающие не только с одним, а с несколькими типами данных.

/*Дженерики и типы соотносятся друг с другом, как значения и аргументы функции. Это такой способ сообщить компонентам
(функциям, классам или интерфейсам), какой тип необходимо использовать при их вызове так же, как во время вызова мы сообщаем функции,
какие значения использовать в качестве аргументов.*/

    function identity <T>(value: T) : T {
        return value;
    }

    console.log(identity<Number>(1))

/*При вызове identity<Number>(1), тип Number — это аргумент, который подставляется везде вместо T.
Функция может принимать несколько типов аналогично тому, как она принимает несколько аргументов.*/