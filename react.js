//Реакт

/*Начнем с того, что React-компоненты это функции, которые мы не вызываем на прямую. Эти функции в некоторые моменты возвращают описание того что нужно рендерить.
Эти функции вызывает сам React в те самые "некоторые" моменты. И React может отложить этот вызов. React рекурсивно обходит дерево компонентов и может применять оптимизации - 
и задерживать рендеры чтобы избежать потерю кадров. React в первую это UI фреймворк, и для того чтобы избежать тормозов такие меры оправданы. Т.к. данные могут поступать быстрее
чем скорость обновления кадров - есть смысл объединять обновления в пакеты и обновлять пакетами. Поэтому React это скорее «Планировщик», и реактивность не провалятся в React
в чистом виде.*/

//Виртуальный ДОМ (Virtual DOM)

/*При рендере компонентов все они складываются в VDOM, на основе которого строится RDOM и затем отображается контент на странице. Манипуляции с RDOM ресурснозатратны, поэтому   
React работает с VDOM, который является легковесной копией RDOM, а в RDOM вносятся только точечные изменения.*/
//

/*JSX – это специальный XML-подобный синтаксис технологии React, который позволяет очень просто описывать пользовательский интерфейс. JSX – это расширение синтаксиса JavaScript,
которое во время компиляции транслируется в обычный JavaScript (вызов React.createElement()).*/

/*Каждый компонент React проходит один и тот же жизненный цикл:

    Компонент монтируется при добавлении на экран.
    Компонент обновляется , когда он получает новые свойства или состояние, обычно в ответ на взаимодействие.
    Компонент размонтируется , когда его убирают с экрана.
    
Жизенный цикл и методы классовых компонентов:   
  монтирование
1) constructor
2) static getDerivedStateFromProps
3) render
4) componentDidMount

  обновления
1) static getDerivedStateFromProps
2) shouldComponentUpdate
3) render
4) getSnapshotBeforeUpdate
5) componentDidUpdate

  размонтирование
1) componentWillUnmount
*/
//

//Обнаружение ошибок рендеринга с помощью границы ошибки

/*Граница ошибки (ErrorBoundary) — это специальный компонент, который позволяет отображать резервный пользовательский интерфейс вместо части, в которой произошел сбой,
например сообщение об ошибке. Он еще не до конца реализован в функциональных компонентах как и forceUpdate.

<ErrorBoundary fallback={<p>Something went wrong</p>}>
  <Profile />
</ErrorBoundary>;
*/
//

//Алгоритм согласования React (React's Reconciliation Algorithm)

/*При первоначальном рендере весь VDOM становиться RDOM. При последующих рендерах использует так называемый «снимок» для сравнения и анализа VDOM до обновления и VDOM после     
обновления (сравнивает два VDOM, ищет различия и вносит изменения в RDOM). 
  - Алгоритм согласования рассматривает тэги и атрибуты и определяет изменились ли они.
  - Так же алгоритм согласования использует ключи (key), чтобы определить, изменилось ли содержимое. По этой причине ключи должны быть уникальными, чтобы при сверке можно было  
  распознать и определить, какие элементы стабильны, а какие нет.*/
//

//Батчинг - это объединение обновлений в одну операцию.

//Контролируемые и неконтролируемые компоненты

/*Неуправляемый компонент работает как обычный элемент формы, получить введенные пользователем значения можно с помощью ref. Управляемый компонент принимает свое текущее
значение в виде пропсов, а также коллбэк-функцию для изменения этого значения.*/

//Порталы

/*Порталы позволяют рендерить дочерние элементы в DOM-узел, который находится вне DOM-иерархии родительского компонента. Порталы особенно спасают когда в родительском компоненте
заданы стили overflow: hidden или z-index, и нужно, чтобы дочерний элемент визуально выходил за рамки своего контейнера. Это диалоги, модальные окна или всплывающие подсказки.*/

//Компоненты высшего порядка (HOC)

/*Компоненты высшего порядка (HOC) - это функция, которая принимает компонент в качестве аргумента и возвращает новый компонент, обертывающий исходный компонент.
HOC позволяют добавлять к компоненту дополнительные функции без изменения кода компонента. HOC могут принимать дополнительные аргументы, что позволяет настроить поведение HOC.
Это делает их гибким и многоразовым способом добавления функциональности вашим компонентам.

Примеры использования HOC:
- аутентификация - вместо дублирования логики аутентификации в каждом компоненте создается HOC withAuth, который проверяет, аутентифицирован ли пользователь, и, если нет,
перенаправляет его на страницу входа.
- ведение журнала - вместо добавления логики ведения журнала к каждому компоненту создается HOC withLogger, который будет обрабатывать функции ведения журнала.
- стилизация и тематика - создается HOC с именем withTheme, который предоставляет компоненту необходимые реквизиты, связанные с темой.

//forwardRef - позволяет вашему компоненту предоставлять DOM-узел родительскому компоненту с помощью ссылки. Родительский компонент передает ссылку на дочерний элемент.
Дочерний компонент перенаправляет эту ссылку на нужный тег (DOM-узел) в своем JSX-коде. В результате родительский компонент может получить доступ к этому DOM-узлу и вызвать его.
forwardRef прокидывает ref в функциональный компонент, так как туда нельзя передать ref через props.

const SomeComponent = forwardRef(render)

const MyInput = forwardRef(function MyInput(props, ref) {
  // ...
});

render: функция рендеринга компонента. React вызывает эту функцию с реквизитами которые компонент получил от своего родителя. Возвращаемый JSX будет результатом работы компонента.
forwardRef возвращает компонент React.
props: реквизиты, передаваемые родительским компонентом.
ref: ref атрибут, передаваемый родительским компонентом.

Примеры использования forwardRef: фокусировка ввода текста, воспроизведение и приостановка видео

//memo - позволяет пропустить повторный рендеринг компонента, если его свойства (props) не изменились (может использоваться в связке с useCallback). React обычно перерисовывает
компонент каждый раз, когда перерисовывает его родительский компонент. С помощью memo можно создать компонент, который React не будет повторно перерисовывать при повторной
визуализации его родителя, если его новые свойства такие же, как и старые. Такой компонент называется мемоизированным. Мемоизация связана только с реквизитами, которые передаются
компоненту от его родителя.

const MemoizedComponent = memo(SomeComponent, arePropsEqual?)

const SomeComponent = memo(function SomeComponent(props) {
  // ...
});

SomeComponent: компонент, который необходимо запомнить запомнить.
arePropsEqual (необязательный) : функция, которая принимает два аргумента: предыдущие реквизиты компонента и его новые реквизиты.  */

//Хуки

/*Есть несколько основных категорий хуков:

- State Hooks (useState, useReducer).
- Context Hooks (useContext).
- Ref Hooks (useRef, useImperativeHandle).
- Effect Hooks (useEffect, useLayoutEffect, useInsertionEffect).
- Performance Hooks (useMemo, useCallback, useTransition, useDeferredValue).

//useState — это React Hook, который позволяет добавлять переменную состояния в компонент.

const [state, setState] = useState(initialState)

initialState: значение состояния, которое будет изначально.
useState возвращает массив ровно с двумя значениями: текущее состояние (state), которое во время первого рендеринга будет соответствовать initialState и функция (setState),
которая позволяет обновить состояние до другого значения и запустить повторный рендеринг.

//useRef

useRef - это React Hook для добавления ссылки. Рефы дают возможность получить доступ к DOM-узлам или React-компонентам.

import { useRef } from 'react';
const ref = useRef(0) - начальное значение можно установить;

useRef возвращает такой объект:

{
  current: 0
}

Для получения доступа к текущему значению ссылки используется свойство ref.current. При изменении значения ссылки повторный рендеринг не вызывается. Сссылки позволяют сохранять
информацию между повторными рендерингами компонента.

Ситуации, когда нужно использовать ссылки:
- хранение идентификаторов тайм-аута.
- хранение и управление элементами DOM.
- сохранение других объектов, которые не нужны для расчета JSX.

//useContext — это React Hook, который позволяет читать контекст компонента, подписываться на него и передавать информацию глубоко вниз без явной передачи реквизитов.
Обычный стейт нужен, когда нужно использовать этот стейт внутри текущего компонента или его ребенка. А useContext нужно использовать, когда состояние много куда передается
через props. Контекст - не универсальное лекарство, поэтому когда есть глобальные данные, их нужно вынести в стейт менеджмент библиотеку.

// Создание контекста

import { createContext } from "react";
const ThemeContext = createContext("light" или ничего);
//

// Применение контекста в разных конмпонентах

function MyPage() {
  return (
    <ThemeContext.Provider value="light">
      <Form />
    </ThemeContext.Provider>
  );
}

function Form() {
  // ... renders buttons inside ...
}

или

import { ThemeContext } from "./Contexts.js";
const theme = useContext(ThemeContext);

//useEffect — это React Hook, который используют для того, чтобы добавить в компонент эффекты с массивом (или без) зависимостей или инициировать запросы.

useEffect(setup, dependencies?)
setup: функция с логикой эффекта. Функция настройки также может опционально возвращать функцию очистки. Когда компонент будет добавлен в DOM, React запустит функцию настройки.
После каждого повторного рендеринга с измененными зависимостями React сначала запускает функцию очистки (если она предоставилена) со старыми значениями,
а затем запускает функцию настройки с новыми значениями. После того, как ваш компонент будет удален из DOM, React запустит функцию очистки.
dependencies: список зависимостей (массив), на которые есть ссылки внутри кода setup.
- если зависимости указаны, Эффект запускается после первоначального рендеринга и после повторного рендеринга с измененными зависимостями.
- если в зависимостях указан пустой массив, то Эффект будет работать только после первоначального рендеринга.
- если вы вообще не передать массив зависимостей, Эффект запускается после каждого рендеринга (и повторного рендеринга) компонента.

//useLayoutEffect — это версия, useEffect которая срабатывает до того, как браузер перерисовывает экран. React гарантирует, что код внутри useLayoutEffect и любые запланированные
внутри него обновления состояния будут обработаны до того, как браузер перерисует экран. Это позволяет отображать всплывающую подсказку (как пример), измерять ее и повторно
отображать всплывающую подсказку, при этом пользователь не заметит первую дополнительную визуализацию. Другими словами, useLayoutEffect блокирует рисование в браузере.

//useMemo — это React Hook, который позволяет кэшировать результат вычислений между повторными рендерингами.

const cachedValue = useMemo(calculateValue, dependencies)
calculateValue: функция, вычисляющая значение, которое нужно кэшировать.
dependencies: спиоск зависимостей.

//useCallback — это React Hook, который позволяет кэшировать определение (ссылки) функции между повторными рендерингами.

const cachedFn = useCallback(fn, dependencies)
fn: значение функции (ссылка на функцию, которая не будет меняться, если не будет меняться массив зависимостей), которое нужно кэшировать.
dependencies: список зависимостей, на которые есть ссылки внутри кода fn.
Примеры использования хука useCallback (для избежания ререндера, оптимизация):
- когда есть необходимость добиться полной мемоизации компонента и в этот компонент передаются функции, то сам компонент оборачивается в HOC memo, а передаваемые
колбэк-функции оборачиваются в хук useCallback.
- если нужно добавить в массив зависимостей useEffect функцию, то она тоже мемоизируется.

//useTransition — это React Hook, который позволяет обновлять состояние, не блокируя пользовательский интерфейс.

const [isPending, startTransition] = useTransition()
isPending - булевое значение, которое определяет происходит ли процедура рендера разбитая на чанки.
startTransition - функция, в которую оборачивается часть логики, которую мы таким образом помечаем как не важное, этим самым разбивая выполнение этой логики на чанки, при этом
не блокируя пользовательский поток.

//useDeferredValue — это React Hook, который позволяет отложить обновление части пользовательского интерфейса.

const deferredValue = useDeferredValue(value)
value: значение, которое нужно отложить.
Данный хук используется, когда нету возможности напрямую оперировать участками кода, которые обновляются (обычно, когда сторонние библиотеки выполняют вычисления для приложения).
В хук оборачиваются значения (value), которые нужно отрисовать. Затем получается новая переменная (deferredValue - закешированная и помеченная, как не срочная к изменениям).
Если будут происходить сложные выисления с этими значениями (value), то будут выводится закешированные значения (defferedValue), не блокирую пользовательский поток.

//useImperativeHandle — это React Hook, который позволяет настраивать дескриптор, отображаемый как ссылка (используется в связке с forwardRef). Вместо предоставления всего узла DOM
можно предоставить собственный объект, называемый императивным дескриптором, с более ограниченным набором методов. Для этого внутри функции forwardRef нужно определить
отдельную ссылку для хранения узла DOM. Далее передаем полученную ref в useImperativeHandle в качестве props и возвращаем описанные нами методы. Если какой-то компонент получит
ссылку на данный компонент, он получит только созданный нами объект с методами вместо узла DOM. Это позволяет вам свести к минимуму информацию, которую вы предоставляете о своем
узле DOM. 

useImperativeHandle(ref, createHandle, dependencies?)

const MyInput = forwardRef(function MyInput(props, ref) {
  useImperativeHandle(ref, () => {
    return {
      // ... your methods ...
    };
  }, []);

ref: значение, которое ref получили в качестве второго аргумента от forwardRef функции рендеринга.
createHandle: функция, которая не принимает аргументов и возвращает дескриптор ссылки, который вы хотите предоставить. Обычно вы возвращаете объект с методами,
которые хотите предоставить.
dependencies (необязательный) : список всех зависимостей.
Пример использования: дать возможность кастомному компоненту вызвать функцию scroll или focus програмно из родительского компонента*/

//Оптимизация приложений:
//1) Оптимизация отображения
// Бесконечная загрузка, виртуализация списков, нет смысла создавать супер вложенную структуру и верстку
//2) React-оптимизации
// юзКолбэк, юзМемо, мемоХОК, юзДефередВэлью (приоритеты реакт-задач), саспенс + лэйзи
//3) Сетевая оптимизация
// Дебаунс, сроттл, аккуратно делать запросы, проверять зависимости эффектов, думать где можно использовать поллинг, где можно использовать сокеты
//4) Оптимизации сборщика кода
// Разделение на чанки, минификация кода, сжатие кода (гзип, бротли)

//Саспенс - компонент обертка для компонентов которые обернуты в лейзи импорт (в него оборачивают все приложение когда используются лейзи чанки, можно не оборачивать,
//но тогда не будет бизи индикатора. Он отслеживает когда в браузер грузится какой-то чанк и отображает спиннер).

//Сборщики кода разбивают приложение на чанки (части, которые грузятся по мере необходимости). Если правильно настроить вебпак или вайт и использовать лейзи хок,
//то он с помощью него разбивает приложение на части. Компонент оборачивается в лейзи импорт.

//Это делает их гибким и многоразовым способом добавления функциональности вашим компонентам.
