/*Разновидности систем контроля версий:
- Локальная система контроля версий
- Централизованная система контроля версий
- Распределенная система контроля версий

Локальная система контроля версий — это локальная база данных, расположенная на вашем локальном компьютере, в которой каждое изменение файла сохраняется в виде исправления. 
Каждый набор патчей содержит только изменения, внесенные в файл с момента его последней версии. Чтобы увидеть, как файл выглядел в тот или иной момент, необходимо сложить в файл
все соответствующие патчи по порядку до данного момента.
Основная проблема заключается в том, что все хранится локально. Если что-нибудь случится с локальной базой данных, все исправления будут потеряны. Если что-нибудь случится с
одной версией, все изменения, внесенные после этой версии, будут потеряны. Кроме того, сотрудничать с другими разработчиками или командой очень сложно или почти невозможно.

Централизованная система контроля версий имеет один сервер, на котором хранятся все версии файлов. Это позволяет нескольким клиентам одновременно получать доступ к файлам
на сервере, переносить их на свой локальный компьютер или отправлять на сервер со своего локального компьютера. Таким образом, каждый обычно знает, что делают остальные участники
проекта. Администраторы имеют контроль над тем, кто и что может делать. Это позволяет легко сотрудничать с другими разработчиками или командой.
Самая большая проблема с этой структурой заключается в том, что все хранится на централизованном сервере. Если что-то случится с этим сервером, никто не сможет сохранить свои
версии изменений, извлечь файлы или вообще сотрудничать. Как и в случае с локальным контролем версий, если центральная база данных повреждена и резервные копии не сохранены,
вы теряете всю историю проекта, за исключением отдельных моментальных снимков, которые люди имеют на своих локальных компьютерах.
Наиболее известными примерами централизованных систем контроля версий являются Microsoft Team Foundation Server (TFS) и SVN.

Распределенные системы контроля версий дает клиентам не просто получать последний снимок файлов с сервера, они полностью зеркалируют репозиторий, включая его полную историю.
Таким образом, каждый, кто работает над проектом, владеет локальной копией всего проекта, т.е. владеет собственной локальной базой данных со своей полной историей.
В этой модели, если сервер становится недоступным или умирает, любой из клиентских репозиториев может отправить копию версии проекта любому другому клиенту или обратно на сервер,
когда она станет доступной. Достаточно того, чтобы один клиент содержал правильную копию, которую затем можно легко распространять дальше.
Git — самый известный пример распределенных систем контроля версий.
*/

/*Репозиторий (repository) — совокупность файлов, состояние которых отслеживается, и история их изменений. По факту, репозиторий — это проект, над которым ведется работа, 
и все изменения в этом проекте. Для отслеживания состояния файла его необходимо добавить в репозиторий.

Коммит (commit) — сохраненное состояние (версия) файлов репозитория.

Ветка (branch) — последовательность коммитов (история изменения состояния репозитория). Каждый коммит в ветке имеет «родителя» (parent commit) — коммит, на основе которого был
получен текущий. В репозитории может быть несколько веток (в случаях, когда к одной версии репозитория применяется несколько независимых изменений).

HEAD — указатель на текущий коммит (указатель на состояние, в котором репозиторий находится на данный момент).

Мастер (master, main) — основная ветка репозитория, создается автоматически при создании репозитория.

Мердж (слияние, merge) — объединение двух или более веток. В процессе мерджа изменения с указанной ветки переносятся (копируются) в текущую.

Целевая ветка мерджа — ветка, изменения с которой объединяются с текущей веткой.

База слияния (merge base) — последний общий коммит двух веток.

Мердж коммит (merge commit) — коммит, который создается автоматически по завершению процесса слияния веток. Мердж коммит содержит в себе все изменения целевой ветки мерджа,
которые отсутствуют в текущей (все коммиты целевой ветки, которые начиная с базы слияния, но не включая её).

Слияние перемоткой (fast-forward merge) — слияние веток, при котором в текущей ветке отсутствуют новые коммиты (последний коммит текущей ветки является базой слияния).
При таком мердже текущая ветка просто переходит в состояние целевой ветки (указатель HEAD переносится на последний коммит целевой ветки). Мердж коммит при этом не создается.

Слияние без перемотки (non fast-forward merge) — слияние, при котором новые коммиты (относительно базы слияния) присутствуют как в текущей, так и в целевой ветках.

Мердж конфликт (merge conflict) — ситуация, когда при слиянии веток в один или несколько файлов вносились независимые изменения. В некоторых случаях
(например, если изменялись разные, не пересекающиеся части одного файла) git способен самостоятельно решить, как выполнять слияние таких файлов. Если автоматически это сделать
не удалось — возникает конфликт. В таком случае необходимо самостоятельно указать, как выполнять слияние конфликтующих версий (решить конфликт, resolve merge conflict). 
Изменения, внесенные в процессе решения конфликта автоматически попадают в мердж коммит.

Чекаут (checkout) — переход на другое (существующее) состояние репозитория (на другой коммит или ветку). При этом все файлы в репозитории возвращаются в состояние,
в котором они находились на момент указанного коммита. Если перед переходом в репозиторий были внесены изменения, которые были добавлены в репозиторий, но не попали в коммит —
они будут перенесены «поверх» состояния после перехода. Как и при мердже, git попробует применить эти изменения к новому состоянию автоматически, при неудаче — 
возникает конфликт и изменения необходимо применить вручную.

Дифф (diff) — разница двух состояний (коммитов, веток, подготовленных или модифицированных файлов).

Трехсторонний дифф (three-way diff) — дифф, возникающий при мердже и решении конфликтов. Является разницей трех состояний: состояния репозитория в текущей ветке, состояния в
целевой ветке слияния и общего состояния между этими ветками (состояния в базе слияния).

Черри-пик (cherry-pick) — процесс добавления в текущую ветку одного (или нескольких с помощью хэшей) коммитов из другой ветки, без необходимости выполнять слияние веток.

Реверт (revert) — отмена внесенных изменений (коммита или группы коммитов). В процессе реверта создается дополнительный коммит, который так же можно отменить при необходимости
(вернув репозиторий в изначальное состояние). Реверт мердж коммита позволяет отменить выполненное ранее слияние веток.

Ребейз (rebase) — перенос изменений текущей ветки «поверх» другой ветки. При этом все коммиты текущей ветки, которых нет в целевой, удаляются из текущей и заново создаются в 
целевой ветке (последовательно применяются к состоянию в целевой ветке). Поскольку ребейз пересоздает коммиты заново и меняет существующую историю, его использование не 
рекомендуется при командной разработке. Ребейз в ветке, над которой работает несколько человек, может привести к потере чужих изменений или невозможности корректно выполнить слияние.*/

/*
git log - просмотр истории коммитов

git pull - это сочетание двух команд fetch и merge. 

отличие pull и fetch: fetch подтягивает изменения с удаленного репозитория, но не вливает их. Pull же подтягивает и вливает изменения в локальный репозиторий.

при клонировании репозитория через SSH необходимо создать ключи в настройках профиля, которые будут служить идентификаторами при клонировании для безопасности

merge и rebase два разных подхода, которые не рекомендуется смешивать между собой.

при использовании merge комиты последовательно заливаются в основную ветку + 1 merge commit (комит, который не несет смысловой нагрузки).

при использование rebase история комитов остается более чистой и последовательной, но происходит замещение комитов (меняется история). По этой причине не просто изменить историю
комитов. Для этого применяется интерактивный rebase, который помогает поменять название комитов и содержимое комитов. В этом режиме очень сложно приметь git pull.       
*/

/*Операции отмены

Git Checkout
Команда git checkout позволяет вернуться к прежнему состоянию файлов в рабочей области. Если были внесены изменения в файл, но еще не добавилены в индекс можно использовать
эту команду, чтобы отменить эти изменения. Просто введите команду и SHA ключ: git checkout SHA ключ

Git Reset
Git Reset позволяет откатить изменения на несколько уровней. Команда git reset может использоваться для отмены изменений в индексе, а также для изменения HEAD.
Есть три основных варианта использования git reset.
- Вернет вас к коммиту, указанному в команде, но оставит изменения в индексе и рабочем каталоге: git reset --soft
- Вернет вас к указанному коммиту, удалив изменения из индекса, но оставив в рабочем каталоге: git reset --mixed
- Полностью вернет вас к указанному коммиту, удалив все изменения из индекса и рабочего каталога: git reset --hard

Git Restore
Команда git restore обычно применяется для возвращения файлов в состояние, которое было зафиксировано в конкретном коммите.
Это незаменимо, когда вы вносите изменения, которые впоследствии желаете откатить. Вот как выглядит базовый синтаксис команды: git restore, git restore --staged,
git restore --source= . Если необходимо отменить все локальные правки в рабочем каталоге, используется следующая команда: git restore -- .

Git Revert
Если вы уже сохраняли ваши изменения в общем репозитории и хотите их отменить, вы должны использовать git revert. Эта команда создает новый коммит, который отменяет изменения
выбранного коммита. Пример использования: git revert HEAD
Это создаст новый коммит, отменяющий все внесённые изменения, произведенные в последнем коммите.
*/

/*Подходы к разработке в среде GIT

Git Flow

Модель ветвления Gitflow предполагает выстраивание строгой модели ветвления вокруг релиза проекта, которая дает надежную схему управления крупными проектами.

1. Вместо использования одной ветки master, в этой модели используется две ветки для записи истории проекта. В ветке master хранится официальная история релиза,
а ветка develop служит в качестве интеграционной ветки для новых функций.
2. Каждая новая функциональность должна разрабатываться в отдельной ветке. Ветки функций создаются не на основе develop. Когда работа над новой функциональностью
завершена, она вливается назад в develop. Новый код не должен отправляться напрямую в master.
3. Когда в ветку develop уже слито достаточно нового кода для релиза (или подходит установленная дата предрелиза), от ветки develop создается ветка release.
В нее новая функциональность уже не добавляется, а производится только отладка багов, создание документации и решение других задач, связанных с релизом. Когда все готово,
ветка release сливается в master, и ей присваивается тег с версией, а ветка релиза удаляется. Кроме этого, она должна быть также слита обратно в ветку develop, в которой
с момента создания ветки релиза могли добавляться изменения. Использование отдельной ветки для подготовки релиза позволяет одной команде дорабатывать текущий релиз пока другая
команда уже работает над функциональностью для следующего релиза.
4. Ветки hotfix используются для быстрого внесения исправлений в рабочую версию кода. Ветки hotfix созданы от master, а не от develop. Как только исправление завершено,
ветка hotfix должна быть объединена как с master, так и с develop (или с веткой текущего релиза), а master должен быть помечен обновленным номером версии. Наличие специальной
ветки для исправления ошибок позволяет команде решать проблемы, не прерывая остальную часть рабочего процесса и не ожидая следующего цикла подготовки к релизу.

Trunk Based Development

Модель ветвления Trunk Based Development характеризуется всего тремя типами веток (master, feature и release) и дает возможность непрерывного деплоя или деплоя по расписанию
в продакшн, так как в master не сливают сложные и плохо протестированные изменения.

Основные моменты Trunk Based Development:
- Ветки, которые живут несколько дней, чтобы ловить минимум конфликтов при слиянии и углубить создание фичи.
- Feature-flags для закрытия «сырого» функционала.
- Continuous Сode Review. Код-ревью фича проходит быстро, так как дифф маленький.
- Чистый мастер, готовый к релизу в любой момент.*/
