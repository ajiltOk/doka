/*Стандарт ECMAScript определяет 8 типов:

    6 типов данных являющихся примитивами:
    Undefined (Неопределённый тип) : typeof instance === "undefined"
    Boolean (Булев, Логический тип) : typeof instance === "boolean"
    Number (Число) : typeof instance === "number"
    String (Строка) : typeof instance === "string"
    BigInt : typeof instance === "bigint", числа, которые больше 2 в степени 53, 4568n
    Symbol (в ECMAScript 6) : typeof instance === "symbol"
    Null (Null тип ) : typeof instance === "object". Специальный примитив, используемый не только для данных но и в качестве указателя на финальную точку в Цепочке Прототипов;
    Object (Объект) : typeof instance === "object".*/

//Существует 3 наиболее широко используемых преобразования: строковое, численное и логическое.

//ФУНКЦИЯ - это блок кода, предназначенный для выполнения определенной задачи.

//ЗАМЫКАНИЕ - это способность функции видеть переменные из внешнего окружения.

let a = 1;

function summ() {
  let b = 2;
  return a + b;
}

summ();

//КОЛБЭК (функция обратного вызова) - это функция, переданная в другую функцию в качестве аргумента, которая затем вызывается по завершению какого-либо действия.

let summ = (a, b, calc) => {
  let result = a + b;
  calc(result);
};

function calc(result) {
  return "Результат сложения:", result;
}

summ(1, 2);

/*This - это ключевое слово, которое имеет особое значение, зависящее от контекста в котором оно применяется. 
Значение "this" – это объект «перед точкой», который используется для вызова метода.*/

/*ФУНКЦИИ-КОНСТРУКТОРЫ – это обычные функции, но с двумя соглашениями:
- имя функции-конструктора должно начинаться с большой буквы.
- функция-конструктор должна выполняться только с помощью оператора "new".*/

//ФУНКЦИИ ВЫСШЕГО ПОРЯДКА — это функции, которые работают с другими функциями, либо принимая их в виде параметров, либо возвращая их.

//РЕКУРСИЯ - это вызов функции из этой же самой функции.

function factorial(n) {
  if (n === 0) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}

factorial(5);

//Rest-оператор(остаточные параметры) - располагается в конце списка параметров функции. Он собирает остальные неуказанные аргументы и делает из них массив.

//Spread-оператор(оператор расширения) - встречается в вызове функции или где-либо ещё. Он извлекает элементы из массива.

/*Named Function Expression или NFE – это термин для Function Expression, у которого есть имя.
Есть две важные особенности ради которого даётся имя функции:
- позволяет функции ссылаться на себя же.
- имя не доступно за пределами функции.*/

//IIFE (Immediately Invoked Function Expression) это JavaScript функция, которая выполняется сразу же после того, как она была определена.

(function () {
  statements;
})();

/*Методы Call(), Apply(), Bind():
- func.call(this = obj, a, b, c) - вызывает функцию с заданными аргументами и устанавливает контекст this = obj.
- func.apply(this = obj, args) - вызывает функцию с аргументами, предоставленными в виде массива и устанавливает контекст this = obj.
- func.bind(this = obj) - создаёт новую функцию, которая при вызове устанавливает в качестве контекста "this" переданный объект. Контекст закрепляется(байндится) за функцией.*/

/*ОСОБЕННОСТИ СТРЕЛОЧНЫХ ФУНКЦИЙ:
- не имеют "this" (его значение берётся снаружи).
- не имеют arguments.
- не могут быть вызваны с помощью оператора "new".
- не имеют "super".*/

/*Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа.

Методы и свойства:

    new Map() – создаёт коллекцию.
    map.set(key, value) – записывает по ключу key значение value.
    map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
    map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
    перебор коллекции for (let key of myMap)*/

/*Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.

Его основные методы это:
    
    new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.
    set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
    set.delete(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
    перебор коллекции for (let key of mySet)*/

/*Use strict - это установка, которая заставляет код обрабатываться в строгом режиме. 
При ее отключении код обрабатывается в неограниченном режиме (т.е. можно задавать значение неопределенной переменной, можно задать одинаковое свойство у объекта и т.д.).*/

/*ОПЕРАТОР НУЛЕВОГО СЛИЯНИЯ(??) - это логический оператор, возвращающий значение правого операнда, если значение левого операнда содержит «null» или «undefined».
В противном случае возвращается значение левого операнда.*/

/*Конструкция «switch(выражение) – case(с чем сравнить)» - сравнивает «выражение» со случаями, перечисленными внутри «case».
А затем выполняет соответствующие инструкции, описанные далее в «case».*/

/*РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ - это шаблоны, используемые для сопоставления последовательностей символов в строках.
В JavaScript регулярные выражения также являются объектами([0-9], [a-zA-z] и т.д.).*/

/*ДЕСТРУКТУРИРУЮЩЕЕ ПРИСВАИВАНИЕ – это специальный синтаксис, который позволяет нам «распаковать» массивы или объекты в несколько переменных*/
let arr = [1, 2];
let [one, two] = arr;

/*ОПЦИОНАЛЬНАЯ ЦЕПОЧКА(?.) - это безопасный способ доступа к свойствам вложенных объектов, даже если какое-либо из промежуточных свойств не существует.
Опциональная цепочка останавливает вычисления и возвращает «undefined», если значение перед (?.) равно «undefined» или «null».*/

/*Поверхностное и глубокое копирование объектов
  При копировании примитивного значения ему присваивается новый адрес в памяти.
  А когда копируется ссылочная переменная (объект), новая переменная будет указывать на место скопированной в памяти (копирование по ссылке).
  Есть два вида копирования: поверхностное и глубокое.
    Создание глубоких копий:
      Если объект, который нужно скопировать, находится на глубине только одного уровня, для создания глубокой копии рекомендуется использовать оператор spread.
      Для более сложных объектов стоит применять комбинацию JSON.parse() и JSON.stringify().
      Для создания глубоких копий также можно использовать сторонние библиотеки.
.*/

/*ГЕНЕРАТОРЫ
  Генераторы являются функциями с возможностью выхода и последующего входа. Их контекст исполнения (значения переменных) сохраняется при последующих входах.
  Когда вызывается функция-генератор, её тело исполняется не сразу, а вместо этого возвращается объект-итератор.
  При вызове метода next() итератора тело функции-генератора исполняется до первого встреченного оператора yield,
который определяет возвращаемое значение или делегирует дальнейшее выполнение другому генератору при помощи yield* anotherGenerator().
  Метод next() возвращает объект со свойством value, содержащим отданное значение, и свойством done, которое указывает, что генератор уже отдал своё последнее значение.
  Вызов метода next() с аргументом прекращает выполнение функции-генератора, и заменяет инструкцию yield на которой было приостановлено выполнение на аргумент переданный в next().*/

function* idMaker() {
  var index = 0;
  while (index < 3) yield index++;
}

var gen = idMaker();

console.log(gen.next().value); // 0
console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
console.log(gen.next().value); // undefined

/*МОДУЛИ
  Модуль – это файл. Чтобы работал import/export, нужно для браузеров указывать атрибут <script type="module".>
  У модулей есть своя область видимости, обмениваться функциональностью можно через import/export.
  В модулях всегда включена директива use strict.
  Код в модулях выполняется только один раз. Экспортируемая функциональность создаётся один раз и передаётся всем импортёрам.*/

/*Сборка мусора выполняется автоматически. Мы не можем ускорить или предотвратить её.
Объекты сохраняются в памяти, пока они достижимы. 
Если на объект есть ссылка – вовсе не факт, что он является достижимым (из корня): набор взаимосвязанных объектов может стать недоступен в целом.*/
